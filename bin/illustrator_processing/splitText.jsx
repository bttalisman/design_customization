#include "~/design_customization/app/assets/javascripts/json2.jsx"function getPNGOptions(){  var pngExportOpts = new ExportOptionsPNG24();  pngExportOpts.antiAliasing = true;  pngExportOpts.artBoardClipping = true;  //pngExportOpts.horizontalScale = 100.0;  //pngExportOpts.matte = true;  //pngExportOpts.matteColor = 0, 0, 0;  pngExportOpts.saveAsHTML = false;  pngExportOpts.transparency = true;  //pngExportOpts.verticalScale = 100.0;  return pngExportOpts;}function hexToRgb( hex ) {  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);  return result ? {    r: parseInt(result[1], 16),    g: parseInt(result[2], 16),    b: parseInt(result[3], 16)  } : null;}// This script is loaded after a document.  Use the path to this document// as the working folder. The doc itself is not used, just close it.var basePath = activeDocument.path;activeDocument.close( SaveOptions.DONOTSAVECHANGES );// This ratio is determined by the actual h_to_w ratio for the placed items// in the template being used.  Each placed item has a ratio of 2.6 / 1.  Both// items together have a ratio of 1.3 / 1.  The images produced by this script// have the same aspect ratio regardless of the aspect ratio of the text.const placedItems_heightToWidthRatio = 1.3;// Load the data file.var dataFileName = basePath + '/text_data.jsn';var read_file = File( dataFileName );read_file.open( 'r', undefined, undefined );var s = read_file.read();read_file.close();var data = JSON.parse( s );var text = data[ 'text' ];// This ratio is for the text itself, not the images.var heightToWidthRatio = data[ 'heightToWidthRatio' ];if( !heightToWidthRatio ) {  heightToWidthRatio = placedItems_heightToWidthRatio;}var newColor = data[ 'color' ];var outputPath = basePath + '/output';var docWidth = data[ 'width' ];if( !docWidth ) {  docWidth = 1000;}var docHeight = docWidth * placedItems_heightToWidthRatio;activeDocument = app.documents.add( DocumentColorSpace.RGB, docWidth, docHeight );var textFrame = activeDocument.textFrames.add();textFrame.contents = text;// We try to make the text as wide as the documentvar textWidth = docWidth;var textHeight = textWidth * heightToWidthRatio;// But if the height of the text is greater than the doc heightif( textHeight > docHeight ){  // We then make the text as high as the doc, and make the width whatever  // it needs to be given the height to width ratio  textHeight = docHeight;  textWidth = docHeight / heightToWidthRatio;}if( (newColor != '') && (newColor != null) ){  var tempName = 'charStyle';  charStyle = app.activeDocument.characterStyles.add( tempName );  charAttr = charStyle.characterAttributes;  aColor = new RGBColor();  var red = hexToRgb( newColor ).r;  var green = hexToRgb( newColor ).g;  var blue = hexToRgb( newColor ).b;  aColor.red = red;  aColor.green = green;  aColor.blue = blue;  charAttr.fillColor = aColor;  charAttr.akiLeft = 150;  charAttr.akiRight = 150;  charStyle.applyTo( textFrame.textRange );}var textGroup = textFrame.createOutline();textGroup.width = textWidth;textGroup.height = textHeight;textGroup.position = [ 0, ( ( (docHeight - textHeight) / 2) + textHeight ) ];activeDocument.artboards[0].artboardRect = [ 0, docHeight, docWidth/2, 0 ];fileName = outputPath + '/left.png';saveInFile = new File( fileName );activeDocument.exportFile( saveInFile, ExportType.PNG24, getPNGOptions() );activeDocument.artboards[0].artboardRect = [ docWidth/2, docHeight, docWidth, 0 ];fileName = outputPath + '/right.png';saveInFile = new File( fileName );activeDocument.exportFile( saveInFile, ExportType.PNG24, getPNGOptions() );activeDocument.close( SaveOptions.DONOTSAVECHANGES );