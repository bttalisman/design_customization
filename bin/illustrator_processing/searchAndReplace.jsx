// see extractTags.jsx
#include "~/design_customization/app/assets/javascripts/json2.jsx"function hexToRgb(hex) {    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);    return result ? {        r: parseInt(result[1], 16),        g: parseInt(result[2], 16),        b: parseInt(result[3], 16)    } : null;}function getPNGOptions(){  var pngExportOpts = new ExportOptionsPNG24();  pngExportOpts.antiAliasing = true;  pngExportOpts.artBoardClipping = true;  //pngExportOpts.horizontalScale = 100.0;  //pngExportOpts.matte = true;  //pngExportOpts.matteColor = 0, 0, 0;  pngExportOpts.saveAsHTML = false;  pngExportOpts.transparency = true;  //pngExportOpts.verticalScale = 100.0;  return pngExportOpts;}var BASE_PATH = activeDocument.path;var DOC_NAME = activeDocument.name;DOC_NAME = DOC_NAME.slice( 0, -3 ); // trim the last three characters '.ai'// Load the file containing prompts mapped to replacement text.var dataFileName = BASE_PATH + '/' + DOC_NAME + '_data.jsn';var charStyle, charAttr, aColor, tempName;var s, read_file, data;try {  read_file = File( dataFileName );  read_file.open( 'r', undefined, undefined );  s = read_file.read();  read_file.close();}catch( e ){  alert( 'could not open data file.' );}try {  data = JSON.parse( s );} catch( e ){  alert( 'could not parse data file. s: ' + s );}var ALL_TAG_SETTINGS = data[ 'tag_settings' ];if(documents.length > 0){  var textFrames = activeDocument.textFrames;  if(textFrames.length > 0)  {    for (var textFrameIndex = 0 ; textFrameIndex < textFrames.length; textFrameIndex++)    {      try      {        var frame = textFrames[ textFrameIndex ]        if( frame )        {          var textLines = frame.lines;          if( textLines.length > 0 )          {            for( var textLineIndex = 0; textLineIndex < textLines.length; textLineIndex++ )            {              var l = textLines[ textLineIndex ];              if( l.contents.indexOf( "<" ) > -1 )              {                var key = l.contents;                var replaceText;                var newColor;                key = key.replace( "<", "" );                key = key.replace( ">", "" );                key = key.replace( / /g, "" );                if( ALL_TAG_SETTINGS[key] === null )                {                  continue;                }                replaceText = ALL_TAG_SETTINGS[ key ][ 'replacement_text' ];                newColor = ALL_TAG_SETTINGS[ key ][ 'text_color' ];                if( (newColor != '') && (newColor != null) )                {                  alert( 'got newColor' );                  // we need a unique name for this character style.  Keys need to be                  // unique, so this name should be unique.                  tempName = 'charStyle_' + key;                  charStyle = activeDocument.characterStyles.add( tempName );                  charAttr = charStyle.characterAttributes;                  // http://jongware.mit.edu/iljscs6html/iljscs6/pc_CharacterAttributes.html                  aColor = new RGBColor();                  var red = hexToRgb( newColor ).r;                  var green = hexToRgb( newColor ).g;                  var blue = hexToRgb( newColor ).b;                  aColor.red = red;                  aColor.green = green;                  aColor.blue = blue;                  charAttr.fillColor = aColor;                  alert( 'about to apply charStyle to: ' + frame );                  charStyle.applyTo( frame.textRange );                } // got a new color                l.contents = replaceText;              } // line contains '<'            } // each line          } // if there are lines        } // if( textRefs[i] )      }      catch( e )      {      }    } // each text frame  } // if there are frames  // Export to JPG  var jpgFileName = BASE_PATH + "/output/" + DOC_NAME + "_mod.jpg";  saveInFile = new File( jpgFileName );  var options = new ExportOptionsJPEG();  options.antiAliasing = true;  options.artBoardClipping = true;  // This is necessary for artemix, but risky cuz the guide names vary  //var guideLayer = app.activeDocument.layers.getByName("Design Guides");  //if( guideLayer != null )  //{  //    guideLayer.visible = false;  //}  activeDocument.exportFile( saveInFile, ExportType.JPEG, options );  activeDocument.exportFile( saveInFile, ExportType.PNG24, getPNGOptions() );  // Save the modified AI file  modAIFileName = BASE_PATH + "/output/" + DOC_NAME + "_mod.ai";  saveInFile = new File( modAIFileName );  activeDocument.saveAs( saveInFile );  activeDocument.close();} // if there are documents
