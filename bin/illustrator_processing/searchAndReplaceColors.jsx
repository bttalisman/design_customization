
#include "~/design_customization/app/assets/javascripts/json2.jsx"function hexToRgb(hex) {  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);  return result ? {      r: parseInt(result[1], 16),      g: parseInt(result[2], 16),      b: parseInt(result[3], 16)  } : null;}function getPNGOptions(){  var pngExportOpts = new ExportOptionsPNG24();  pngExportOpts.antiAliasing = true;  pngExportOpts.artBoardClipping = true;  //pngExportOpts.horizontalScale = 100.0;  //pngExportOpts.matte = true;  //pngExportOpts.matteColor = 0, 0, 0;  pngExportOpts.saveAsHTML = false;  pngExportOpts.transparency = true;  //pngExportOpts.verticalScale = 100.0;  return pngExportOpts;}var BASE_PATH = activeDocument.path;var DOC_NAME = activeDocument.name;DOC_NAME = DOC_NAME.slice( 0, -3 ); // trim the last three characters// Load the file containing replacement color informationvar dataFileName = BASE_PATH + '/' + DOC_NAME + '_data.jsn';var read_file, s, data;try {  read_file = File( dataFileName );  read_file.open( 'r', undefined, undefined );  s = read_file.read();  read_file.close();}catch( e ){  alert( 'could not open data file.' );}try {  data = JSON.parse( s );}catch( e ){  alert( 'could not parse data file.  s: ' + s );}var ALL_COLOR_SETTINGS = data.color_settings;//alert( 'ALL_COLOR_SETTINGS: ' + JSON.stringify( ALL_COLOR_SETTINGS ) );// Dealing with floating point values, close enough countsfunction is_pretty_close( a,  b ){  var bReturn = false;  var dif = Math.abs( a - b );  if( dif < 0.001 ) {    bReturn = true;  }  return bReturn;}// Iterate through all of the color keys in the settings object.  If all of the// color values match, we've found our item.function find_in_settings( color ){  var key;  var bFound = false;//  alert( 'finding: ' + color.cyan + ', ' + color.magenta + ', ' + color.yellow + ', ' + color.black );  for ( key in ALL_COLOR_SETTINGS )  {    if (ALL_COLOR_SETTINGS.hasOwnProperty(key)) {      if( is_pretty_close( parseFloat( ALL_COLOR_SETTINGS[key].orig_c ), color.cyan ) &&          is_pretty_close( parseFloat( ALL_COLOR_SETTINGS[key].orig_m ), color.magenta ) &&          is_pretty_close( parseFloat( ALL_COLOR_SETTINGS[key].orig_y ), color.yellow ) &&          is_pretty_close( parseFloat( ALL_COLOR_SETTINGS[key].orig_k ), color.black ) )      {//        alert( 'found' );        bFound = true;        break;      }    } // it's really a key  } // for each key in ALL_COLOR_SETTINGS  if( bFound ) {    return key; }  return null;}function is_valid_cmyk( settings ){  var bValid = false;  if( typeof(settings.new_c) == 'number' &&      typeof(settings.new_m) == 'number' &&      typeof(settings.new_y) == 'number' &&      typeof(settings.new_k) == 'number' )  {    bValid = true;  }  return bValid;}function get_new_color( key ){  var settings = ALL_COLOR_SETTINGS[ key ];  if( is_valid_cmyk( settings ) )  {    newColor = new CMYKColor();    newColor.cyan = settings.new_c;    newColor.magenta = settings.new_m;    newColor.yellow = settings.new_y;    newColor.black = settings.new_k;  }  else  {    var rgb = hexToRgb( settings.new_hex );    newColor = new RGBColor();    newColor.red = rgb.r;    newColor.blue = rgb.b;    newColor.green = rgb.g;  }  return newColor;}// If a color is a gradient color, we've got to get the stops, otherwise we// can just deal with the color itself.  Look up the key in settings, if it's// there, then we've found a color to replace, get the new color and make the// swap.function process_color( color, item, bIsFill ){  var colorType = color.typename;  var key;  if( colorType === 'GradientColor' )  {    var grad = color.gradient;    var stops = grad.gradientStops;    var gradStopsCount = stops.length;    for( var stopIndex = 0; stopIndex < gradStopsCount; stopIndex++ )    {      var stop = stops[ stopIndex ];      key = find_in_settings( stop.color );      if( key ) {        stop.color = get_new_color( key ); }    }  }  else  {    // not a gradient color    key = find_in_settings( color );    if( key ) {      var newColor = get_new_color( key );      if( bIsFill ) {        item.fillColor = newColor; }      else {        item.strokeColor = newColor; }    }  } // not a gradient color}// Here's the main processing code.if(documents.length > 0){  // Go through all page items.  var pageItems = activeDocument.pageItems;  var pageItemCount = pageItems.length;  for( var itemIndex = 0; itemIndex < pageItemCount; itemIndex++ )  {    var item = pageItems[ itemIndex ];    try    {      var color = item.fillColor;      if( color ) {        process_color( color, item, true ); }    }    catch( e ) {}    try    {      color = item.strokeColor;      if( color ) {        process_color( color, item, false ); }    }    catch( e ) {}  } // for each page item  // Deal with all text.  Text does not show up in pageItems  var textFrames = activeDocument.textFrames;  if(textFrames.length > 0)  {    for (var textFrameIndex = 0 ; textFrameIndex < textFrames.length; textFrameIndex++)    {      if( textFrames[textFrameIndex] )      {        var lines = textFrames[textFrameIndex].lines;        if( lines.length > 0 )        {          for( var lineIndex = 0; lineIndex < lines.length; lineIndex++ )          {            var textRange = lines[ lineIndex ];            var charAttributes = textRange.characterAttributes;            try            {              var color = charAttributes.fillColor;              if( color ) {                process_color( color, charAttributes, true ); }            }            catch( e ) {}            try            {              color = charAttributes.strokeColor;              if( color ) {                process_color( color, charAttributes, false ); }            }            catch( e ) {}          } // each line        } // if there are lines      } // if( textRefs[i] )    } // each text frame  } // if there are frames} // if there are documents



 // Export to JPG

 var jpgFileName = BASE_PATH + "/output/" + DOC_NAME + "_mod.jpg";
 saveInFile = new File( jpgFileName );

 var options = new ExportOptionsJPEG();
 options.antiAliasing = true;
 options.artBoardClipping = true;

 activeDocument.exportFile( saveInFile, ExportType.JPEG, options );
 activeDocument.exportFile( saveInFile, ExportType.PNG24, getPNGOptions() );


 // Save the modified AI file
 modAIFileName = BASE_PATH + "/output/" + DOC_NAME + "_mod.ai";
 saveInFile = new File( modAIFileName );
 activeDocument.saveAs( saveInFile );


 activeDocument.close();
